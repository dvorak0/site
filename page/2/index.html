<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.111.2"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Seeking Complexity</title><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Seeking Complexity"></head><body><header><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?41e2e31fcfdb815d942715d44866f9fc",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script>========================<br>== <a href=https://yangzhenfei.com>Seeking Complexity</a> ==<br>========================<div style=float:right></div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/about/><b>About</b></a>.</nav></p><script src=https://yangzhenfei.com/js/mathjax-config.js></script>
<script type=text/javascript src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></header><main><article><h1><a href=https://yangzhenfei.com/posts/20220301101256-nix/>nix</a></h1><b><time>2022-03-01 10:12:00</time></b>
<a href=/tags/public>PUBLIC</a><div></div></article><article><h1><a href=https://yangzhenfei.com/posts/20220224200513-sicp/>从SICP说起：重新学习（函数式）编程</a></h1><b><time>2022-02-24 20:05:00</time></b>
<a href=/tags/public>PUBLIC</a><div>从SICP说起 2021年开始，我把主力编辑器换成了 emacs ， 折腾的过程里，似懂非懂地写了一部分 elisp ， 也自然地想起了在本科的时候一直藏在收藏夹里的书：SICP。
惭愧的是，虽然一直知道这本书，实际上却从来没有完整地阅读过。 没想到这次阅读成了一次开端，让我有一种重新学习编程的感觉。
对函数式编程的第一印象 看完SICP前几章之后，印象最深刻的特性是：immutable，stateless，pure function。
这些特性加起来，可以总结出FP的审美倾向：我想要一个static computational graph（directed acyclic graph），而不是一个dynamic state machine（looply graph）。
结合平常写代码的经历，追踪state的变化和理解不同时刻同一个state的含义，确实消耗了大量心智带宽。
而自然的，我们常用的冯诺依曼机器是以存储（也就是状态）为核心的，如何高效地在OOP machine上实现FP呢？
这就需要一些technique的辅助：lazy evaluation/garbage collection：
lazy evaluation把所有可能的状态都提前声明，例如一个state在所有timestamp的record，但是只有真正需要的时候才触发计算。 （这里有点像一个把戏，state其实还是在变化的，但是每次变化我们都认为他是一个新的state_i，以此来保证state_0永远是state_0）。 garbage collection：提前声明的变量那么多，自然有许多是用不到了，那就需要GC去释放资源了。 一些参考 比我总结的更好的FP特性：doing it the fp way in cpp
Immutable variables
In functional programming, you can’t modify a variable after it’s been initialized. You just can’t. You can create new variables but you can’t modify existing variables.
No side effects
<a href=https://yangzhenfei.com/posts/20220224200513-sicp/>Read more...</a></div></article><article><h1><a href=https://yangzhenfei.com/posts/20220222101253-%E5%A4%8D%E5%90%88%E6%80%9D%E8%80%83/>复合思考</a></h1><b><time>2022-02-22 10:12:00</time></b>
<a href=/tags/public>PUBLIC</a><div>forty-year_career中提到：
One section in Coders at Work, I believe it was Joe Armstrong’s, described spending four hours a week thinking about the future. Each week, their thinking would compound on the previous week’s, letting them see further and further into the future. Over time they were dreaming far beyond their contemporaries.
类似的想法还有：
second-order-thinking node & edge 写下思考，内容有两部分：
直观地展示想要什么，可以认为是node 不同的milestone之间的逻辑经不经得起推敲，可以认为是edge</div></article><article><h1><a href=https://yangzhenfei.com/posts/20220215203814-public_or_private/>public_or_private</a></h1><b><time>2022-02-15 20:38:00</time></b>
<a href=/tags/public>PUBLIC</a><div>https://news.ycombinator.com/item?id=34223288</div></article><article><h1><a href=https://yangzhenfei.com/posts/20220209192754-emacs/>guide of emacs for vim user</a></h1><b><time>2022-02-09 19:27:00</time></b>
<a href=/tags/public>PUBLIC</a><div>目标用户 singularity追求者 vim vim的modal editing模式非常受欢迎，尤其是以hjkl motion movement为核心的keybinding。
而vim keybinding比vim本身更加流行，浏览器 各种IDE，一些terminal都有vim keybinding。 所以值得一问：
我是喜欢vim还是喜欢vim keybinding
as elisp interpreter emacs最大的特点可能是emacs本身是一个emacs lisp的解释器，大部分emacs的代码都由elisp写成，包括配置文件本身。 与编辑器交互的command，也就是在解释器里执行新的function。
lisp本身是一个很有魅力的语言，简洁的语法，彻底的functional programming支持。 可以在经典教材SICP中看到很全面的介绍。也可以参考Paul Graham的lisp 洗脑文。
另外一点值得一提的是这个lisp解释器的server-client结构。 vim和其他的编译器也有类似的结构，但是可能是因为语言的原因，使用的并不多。 而在emacs中就经常见到一些很灵活的操作，一个我比较喜欢的例子是：org-pomodoro&amp;polybar 写一个shell script，通过 emacsclient -e 执行在emacs配置中声明的一个函数，获取一个文本输出。再把这个shell script放到桌面管理器status line的callback里，做到在桌面显示emacs内部的信息。
org-mode org-mode直接看起来是一个类似markdown的东西，一种标记语法。
使它看起来独特的原因有下面几个点：
structure editing 包括报表在内，有一套比较方便的键盘操作：交换章节、提高/降低层级、加TODO
literal programming 类似jupyter，可以边写代码，边写文档，文档中可以直接包含代码的输出。
digraph G { splines=false; subgraph cluster_1 { problem1[label="问题"] solve1[label="解法"] result1[label="结果"] problem1->solve1->result1 } solve2[label="解法2"] problem1->solve2->result1 } GTD 一个永远准备 capture TODO项的GTD系统。
例如正在coding，可以使用 org-capture 加一个TODO
这部分的介绍太多了，应该是很多人入坑emacs的原因。 很多非程序员也在使用emacs，用org-mode做GTD应该算是一个比较主流的原因之一。
we love UI: TUI & GUI emacs是一个完整的GUI程序，所以能享受众多GUI程序的基本人权：
<a href=https://yangzhenfei.com/posts/20220209192754-emacs/>Read more...</a></div></article><article><h1><a href=https://yangzhenfei.com/posts/20211217144946-latency_numbers/>latency_numbers</a></h1><b><time>2021-12-17 14:49:00</time></b>
<a href=/tags/public>PUBLIC</a><div>延迟 Latency Comparison Numbers (~2012) L1 cache reference 0.5 ns Branch mispredict 5 ns L2 cache reference 7 ns 14x L1 cache Mutex lock/unlock 25 ns Main memory reference 100 ns 20x L2 cache, 200x L1 cache Compress 1K bytes with Zippy 3,000 ns 3 us Send 1K bytes over 1 Gbps network 10,000 ns 10 us Read 4K randomly from SSD* 150,000 ns 150 us ~1GB/sec SSD Read 1 MB sequentially from memory 250,000 ns 250 us Round trip within same datacenter 500,000 ns 500 us Read 1 MB sequentially from SSD* 1,000,000 ns 1,000 us 1 ms ~1GB/sec SSD, 4X memory Disk seek 10,000,000 ns 10,000 us 10 ms 20x datacenter roundtrip Read 1 MB sequentially from disk 20,000,000 ns 20,000 us 20 ms 80x memory, 20X SSD Send packet CA->Netherlands->CA 150,000,000 ns 150,000 us 150 ms Notes
<a href=https://yangzhenfei.com/posts/20211217144946-latency_numbers/>Read more...</a></div></article><article><h1><a href=https://yangzhenfei.com/posts/20211215182434-geometric_algebra/>geometric_algebra</a></h1><b><time>2021-12-15 18:24:00</time></b>
<a href=/tags/public>PUBLIC</a><div>A Swift Introduction to Geometric Algebra</div></article><article><h1><a href=https://yangzhenfei.com/posts/20211213123832-%E5%86%A5%E6%83%B3/>冥想</a></h1><b><time>2021-12-13 12:38:00</time></b>
<a href=/tags/public>PUBLIC</a><div>TLDR 大脑的gym 不是发呆，是一种刻意练习，也许要技巧的辅助，并不轻松 netflix的冥想正念指南 如何开始 冥想就像是坐在路边，看思绪如车辆一般驶入，但是我们并不参与其中。
如何爱上生活 找到感恩的瞬间，感受这个瞬间的状态，强化这种感觉
如何应对压力 对冥想时的杂念进行标记，是思绪还是压力
如何善待他人 想象一个画面，自己 关心的人 讨厌的人，都在某些信号下(阳光洒满全身)，满脸笑容，感受他的快乐
如何应对身体伤痛 想象扫描身体，感受疼痛但是不参与
如何应对愤怒 想象一个关心的人坐在对面，在吸气时把他的痛苦吸走，在呼气时用幸福快乐的感觉填充。同样是一个用来把自己中立出来，观察真正的事务的方法。</div></article><article><h1><a href=https://yangzhenfei.com/posts/20211213123539-%E8%AF%81%E4%BC%AA/>证伪</a></h1><b><time>2021-12-13 12:35:00</time></b>
<a href=/tags/public>PUBLIC</a><div>Motivation 如果一个理论可以强大地推导出任意理论，可能反而是无意义的。
历史上一个参考是弗洛伊德的对梦的解释。还有被熟知的：房间里有一头无法被任何方法探测的大象。
应用 一个理论，被定义属于科学的一个条件：可能被“未来的”某种现象打败。
补充 证伪的定义主要是为了区分方便，本身是个中立，正如科学在一众宗教的关系。
不需要区分高下。
存在许多无法证伪的理论，也可以给我们许多启发，或者至少是一种难得的寄托吧。
另外一个有趣的事实，这个规则更强调对物理世界的研究，按这个规定，数学也被排除在科学圈外。
启发 寻找错误，是比证明一个道理，更加有力的。
我们有时候会以为自己懂了，以为证明出来了。而反例则往往能破除这种幻想。
难怪，对话体，作为一种常见的知识记录问题，在上古时候特别流行：论语、金刚经、理想国。
graham也提到notice anomalies，是获取new idea的方法，当你在一个领域做的足够深入，会发现令人费解的gap。</div></article><article><h1><a href=https://yangzhenfei.com/posts/20211213123003-double_entry_bookkeeping/>double-entry_bookkeeping</a></h1><b><time>2021-12-13 12:30:00</time></b>
<a href=/tags/public>PUBLIC</a><div>double entry
\[income + expenses + equity + liability = 0\]</div></article><div><a href=/>Previous Page</a>
2 of 3
<a href=/page/3/>Next Page</a></div></main><footer><p>&copy; 2023 <a href=https://yangzhenfei.com><b>Seeking Complexity</b></a>.</p></footer></body></html>