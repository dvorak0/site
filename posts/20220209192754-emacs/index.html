<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>guide of emacs for vim user</title><link rel=stylesheet href=../../css/style.css></head><body><header><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?41e2e31fcfdb815d942715d44866f9fc",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script>========================<br>== <a href=https://www.yangzhenfei.com>Seeking Complexity</a> ==<br>========================<div style=float:right></div><br><p><nav><a href=../../><b>Start</b></a>.
<a href=../../posts/><b>Posts</b></a>.
<a href=../../about/><b>About</b></a>.</nav></p><script src=https://www.yangzhenfei.com/js/mathjax-config.js></script>
<script type=text/javascript async src=https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js></script></header><main><article><h1>guide of emacs for vim user</h1><b><time>2022-02-09 19:27:00</time></b>
<a href=../../tags/public>PUBLIC</a><div><h2 id=目标用户>目标用户</h2><h3 id=singularity追求者>singularity追求者</h3><h2 id=vim>vim</h2><p>vim的modal editing模式非常受欢迎，尤其是以hjkl motion movement为核心的keybinding。</p><p>而vim keybinding比vim本身更加流行，浏览器 各种IDE，一些terminal都有vim keybinding。
所以值得一问：</p><p>我是喜欢vim还是喜欢vim keybinding</p><h2 id=as-elisp-interpreter>as elisp interpreter</h2><p>emacs最大的特点可能是emacs本身是一个emacs lisp的解释器，大部分emacs的代码都由elisp写成，包括配置文件本身。
与编辑器交互的command，也就是在解释器里执行新的function。</p><p>lisp本身是一个很有魅力的语言，简洁的语法，彻底的functional programming支持。
可以在经典教材<a href=../../posts/20220224200513-sicp/>SICP</a>中看到很全面的介绍。也可以参考Paul Graham的<a href=http://www.paulgraham.com/lisp.html>lisp 洗脑文</a>。</p><p>另外一点值得一提的是这个lisp解释器的server-client结构。
vim和其他的编译器也有类似的结构，但是可能是因为语言的原因，使用的并不多。
而在emacs中就经常见到一些很灵活的操作，一个我比较喜欢的例子是：<a href=https://colekillian.com/posts/org-pomodoro-and-polybar/>org-pomodoro&amp;polybar</a>
写一个shell script，通过 <code>emacsclient -e</code> 执行在emacs配置中声明的一个函数，获取一个文本输出。再把这个shell script放到桌面管理器status line的callback里，做到在桌面显示emacs内部的信息。</p><h2 id=org-mode>org-mode</h2><p>org-mode直接看起来是一个类似markdown的东西，一种标记语法。</p><figure><img src=../../ox-hugo/2022-04-12_13-24-42_screenshot_hu674d9033ff4ddaa6bbdab1b4796cafaa_260114_1623x1437_resize_q75_h2_box_3.webp></figure><p>使它看起来独特的原因有下面几个点：</p><h3 id=structure-editing>structure editing</h3><p>包括报表在内，有一套比较方便的键盘操作：交换章节、提高/降低层级、加TODO</p><figure><img src=../../ox-hugo/2022-04-12_14-05-01_output.gif></figure><h3 id=literal-programming>literal programming</h3><p>类似jupyter，可以边写代码，边写文档，文档中可以直接包含代码的输出。</p><pre tabindex=0><code class=language-dot data-lang=dot>digraph G {
splines=false;
  subgraph cluster_1 {
    problem1[label=&#34;问题&#34;]
    solve1[label=&#34;解法&#34;]
    result1[label=&#34;结果&#34;]
    problem1-&gt;solve1-&gt;result1
  }
  solve2[label=&#34;解法2&#34;]
  problem1-&gt;solve2-&gt;result1
}
</code></pre><figure><img src=../../ox-hugo/lidar_vision_hu35ca48866f533cfdf5513b0ad7fc5591_17411_224x293_resize_q75_h2_box_3.webp></figure><h3 id=gtd>GTD</h3><p>一个永远准备 <code>capture</code> TODO项的GTD系统。</p><p>例如正在coding，可以使用 <code>org-capture</code> 加一个TODO</p><p>这部分的介绍太多了，应该是很多人入坑emacs的原因。
很多非程序员也在使用emacs，用org-mode做GTD应该算是一个比较主流的原因之一。</p><h2 id=we-love-ui-tui-and-gui>we love UI: TUI & GUI</h2><p>emacs是一个完整的GUI程序，所以能享受众多GUI程序的基本人权：</p><ul><li>丰富的字体选择（不只是等宽字体）</li><li>内嵌图片，上面literal programming已经介绍过。也可以（在编辑过程中）嵌入渲染好的latex公式（实际上是图片）</li><li>鼠标点击和下拉菜单，很多TUI中的文字其实是按钮。</li></ul><p>在GUI和command line两个极端之间，我认为TUI是非常吸引人的一个选项。</p><p>现在有一种潮流是用rust重写很多CLI工具，其中一个特点就是具有非常丰富的TUI。
<a href=https://github.com/jesseduffield/lazygit>lazygit</a>应该算是一个非常有代表性的例子（虽然很快就要说到lazygit是在重复造一个emacs中存在已久的轮子）。</p><h2 id=magit>magit</h2><figure><img src=../../ox-hugo/2022-04-20_22-30-35_screenshot_hu65c0d9649339b3c3a91a47ce679daa8c_94805_700x520_resize_q75_h2_box_3.webp><figcaption><span class=figure-number>Figure 1: </span>magit</figcaption></figure><figure><img src=../../ox-hugo/2023-01-13_21-15-58_screenshot_hu36e33a8c0f17cb4e6dedb89044aab1be_90108_888x666_resize_q75_h2_box_3.webp><figcaption><span class=figure-number>Figure 2: </span>跟github cli的集成（pr issue）</figcaption></figure><p>magit是emacs中常用的git工具。想来想去觉得用下面这个文章最好说明他的设计思想：<a href=https://hongchao.me/cli-and-emacs/>Emacs is the 2D Command-line Interface</a>。</p><p>magit是一个TUI工具，但是他每个显示的文字都是一个潜在的按钮。所以配合光标停留的位置，加上快捷键就可以表达verb+noun。</p><p>（好像想到了老罗的TNT）</p><h2 id=tramp>tramp</h2><p>emacs中用来remote editing的工具。</p><p>vim常常被认为是适合远程编辑的：通过ssh登录，在terminal中执行vim。然后可怕的就来了，每次按键都要经历一次网络延迟。</p><p>这明显不是一个合理的设计，起码不适合长期工作。</p><p>VSCode中的remote设计的比较好（几乎和emacs一样好），编辑器会维护一个副本，隔离开高频的按键操作和低频的同步操作。</p><p>tramp是emacs中一个非常基础的模块，当你编辑一个远程文件的时候（文件名常常是类似 <code>user@host:/path/to/remote/file</code> ，甚至可以pipe， <code>user@host|docker:user@host:/path/to/remote/file</code> ），其他的插件几乎是可以开箱即用：</p><ul><li>grep可以知道在远程搜索文件</li><li>language server知道应该索引远程的工程</li><li>magit也知道应该在远程做git操作</li></ul><p>tramp的设计完成度很高，是一层很好的设计。</p><h2 id=可维护度>可维护度</h2><p>vim的维护者主要是BM一个人。当初neovim之所以fork出来，就是因为一个关于async action的PR被BM拒绝了（当然后面又自己加上了，这个时候neovim已经分道扬镳了）。</p><p>neovim明显不打算跟vim保持兼容性了，从配置语言开始，neovim跟vim已经不是一个东西了，以后应该会差别越来越大。</p><p>谁知道以后会不会又有oenvim呢。</p><p>更可怕的是： what if BM dies&mldr;</p><h2 id=plugin>plugin</h2><p>基本说完了，plugin算是最不重要的了，几乎都有比较等价的实现。
不过还是说几个确实非常独特的plugin：</p><h3 id=org-roam>org-roam</h3><p>可以认为是<a href=https://roamresearch.com/>roam research</a>的开源实现。而roam research是<a href=https://en.wikipedia.org/wiki/Zettelkasten>zettelkasten笔记法</a>的一个商业实现。</p><p>最近类似的note taking工具越来越多，简单总结这类工具就是尝试把过去常用的树形笔记结构，变成图的形状，靠各种双向链接来建造知识库。</p><h3 id=evil>evil</h3><p>emacs中的vim keybinding。</p><p>感慨一下，实现一个vim的keybinding感觉还是非常麻烦的。。。佩服。</p><p>可惜的是很多vim的motion插件，自然是不能使用的。</p></div></article></main><script src=https://utteranc.es/client.js repo=dvorak0/site issue-term=pathname theme=github-light crossorigin=anonymous async></script><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=../../posts/20230510165215-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86geohot/>重新认识geohot</a></li><li><a href=../../posts/20230417104236-intelligential_honest/>intelligential honest</a></li><li><a href=../../posts/20230315161517-incremental_run/>Universal Caching, lessons learned from NX</a></li><li><a href=../../posts/20230109104349-make_the_world_a_better_place/>make the world a better place</a></li><li><a href=../../posts/20221205145412-low_information_heuristics/>low_information_heuristics</a></li></ul></div></div></aside><footer><p>&copy; 2023 <a href=https://www.yangzhenfei.com><b>Seeking Complexity</b></a>.</p></footer></body></html>