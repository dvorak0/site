<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Site</title><link>https://yangzhenfei.com/posts/</link><description>Recent content in Posts on Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Apr 2022 11:03:00 +0800</lastBuildDate><atom:link href="https://yangzhenfei.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>anki</title><link>https://yangzhenfei.com/posts/20220415110303-anki/</link><pubDate>Fri, 15 Apr 2022 11:03:00 +0800</pubDate><guid>https://yangzhenfei.com/posts/20220415110303-anki/</guid><description>ankijazz</description></item><item><title>nix</title><link>https://yangzhenfei.com/posts/20220301101256-nix/</link><pubDate>Tue, 01 Mar 2022 10:12:00 +0800</pubDate><guid>https://yangzhenfei.com/posts/20220301101256-nix/</guid><description/></item><item><title>SICP</title><link>https://yangzhenfei.com/posts/20220224200513-sicp/</link><pubDate>Thu, 24 Feb 2022 20:05:00 +0800</pubDate><guid>https://yangzhenfei.com/posts/20220224200513-sicp/</guid><description>immutability有很多好处，但是对于程序运行效率有很大的影响。 而有一种这种的方法是给语言加上惰性求值的特性，这样就可以编码出来一个“无限长的随机数序列”，但是只有我们访问的时候，才会去真正的生成。
这个想法也呼应了为什么nix作为配置工具，被设计成函数式语言。</description></item><item><title>guide of emacs for vim user</title><link>https://yangzhenfei.com/posts/20220209192754-emacs/</link><pubDate>Wed, 09 Feb 2022 19:27:00 +0800</pubDate><guid>https://yangzhenfei.com/posts/20220209192754-emacs/</guid><description>目标用户 singularity追求者 vim vim的modal editing模式非常受欢迎，尤其是以hjkl motion movement为核心的keybinding。
而vim keybinding比vim本身更加流行，浏览器 各种IDE，一些terminal都有vim keybinding。 所以值得一问：
我是喜欢vim还是喜欢vim keybinding
as elisp interpreter emacs最大的特点可能是emacs本身是一个emacs lisp的解释器，大部分emacs的代码都由elisp写成，包括配置文件本身。 与编辑器交互的command，也就是在解释器里执行新的function。
lisp本身是一个很有魅力的语言，简洁的语法，彻底的functional programming支持。 可以在经典教材SICP中看到很全面的介绍。也可以参考Paul Graham的lisp 洗脑文。
另外一点值得一提的是这个lisp解释器的server-client结构。 vim和其他的编译器也有类似的结构，但是可能是因为语言的原因，使用的并不多。 而在emacs中就经常见到一些很灵活的操作，一个我比较喜欢的例子是：org-pomodoro&amp;amp;polybar 写一个shell script，通过 emacsclient -e 执行在emacs配置中声明的一个函数，获取一个文本输出。再把这个shell script放到桌面管理器status line的callback里，做到在桌面显示emacs内部的信息。
org-mode org-mode直接看起来是一个类似markdown的东西，一种标记语法。
使它看起来独特的原因有下面几个点：
structure editing 包括报表在内，有一套比较方便的键盘操作：交换章节、提高/降低层级、加TODO
literal programming 类似jupyter，可以编写代码，边写文档，文档中可以直接包含代码的输出。
digraph G { splines=false; subgraph cluster_1 { problem1[label=&amp;#34;问题&amp;#34;] solve1[label=&amp;#34;解法&amp;#34;] result1[label=&amp;#34;结果&amp;#34;] problem1-&amp;gt;solve1-&amp;gt;result1 } solve2[label=&amp;#34;解法2&amp;#34;] problem1-&amp;gt;solve2-&amp;gt;result1 } GTD 一个永远准备 capture TODO项的GTD系统。
例如正在coding，可以使用 org-capture 加一个TODO
这部分的介绍太多了，应该是很多人入坑emacs的原因。 很多非程序员也在使用emacs，用org-mode做GTD应该算是一个比较主流的原因之一。
we love UI: TUI &amp;amp; GUI emacs是一个完整的GUI程序，所以能享受众多GUI程序的基本人权：</description></item><item><title>tools</title><link>https://yangzhenfei.com/posts/20211115121752-tools/</link><pubDate>Mon, 15 Nov 2021 12:17:00 +0800</pubDate><guid>https://yangzhenfei.com/posts/20211115121752-tools/</guid><description>singularity 这里记录能帮助尽快接近singularity的方法。
一般来说，学习曲线陡峭~=能形成累计优势：
一次学习， 终生 受用 不与非开放平台绑定 越用越熟练，上限高，不会浪费时间投入 我的工具 emacs nix/nixos/home-manager anki woboq i3wm+i3block bitwarden TODO RSSHub整理 chromeos: linux+android rime：跨平台词库同步 双拼 intro nixos i3 emacs lsp rust c++ python javascript</description></item></channel></rss>